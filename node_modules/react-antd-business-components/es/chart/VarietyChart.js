import { useState, useEffect, useMemo } from "react";
import classnames from "classnames";
import { AreaChart, Area, BarChart, Bar, ComposedChart, Line, LineChart, CartesianGrid, XAxis, YAxis, Tooltip, Brush, Legend, ResponsiveContainer } from "recharts";
import { getNiceTickValues } from "recharts-scale";
import { getStringLength, getStringDOMWidth, getFormatValue } from "business-utils";
import RechartsTooltip from "./Tooltip";
import CustomizedLegend from "./CustomizedLegend";
import useFormat from "./useFormat";
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
const container = "rabc-chart-variety-chart__container";
const styles = {
  container
};
const colors = ["#1890ff", "#13c2c2", "#52c41a", "#a0d911", "#fadb14", "#faad14", "#f5222d", "#fa541c", "#fa8c16", "#ffbf00", "#f56a00", "#f7a20f", "#108ee9", "#00a2ae", "#eb2f96", "#722ed1", "#2f54eb"];
function VarietyChart(props) {
  const {
    type,
    xAxisFormatter = (v) => v,
    yAxisFormatter = (v) => v,
    width,
    height,
    layout,
    stackOffset,
    brush,
    useResponsiveContainer,
    data: {
      chartData = [],
      dataKeys = [],
      dataKeys: originDataKeys
    } = {},
    ...restProps
  } = props;
  let {
    xAxisFormat = "",
    yAxisFormat = ""
  } = props;
  const isVertical = layout === "vertical";
  const [dataKeysToRender, setDataKeysToRender] = useState(dataKeys);
  useEffect(() => {
    setDataKeysToRender(originDataKeys || []);
  }, [originDataKeys]);
  if (stackOffset === "expand") {
    if (isVertical) {
      xAxisFormat = "percent(0)";
    } else {
      yAxisFormat = "percent(0)";
    }
  }
  const formatOptions = {
    layout,
    stackOffset,
    xAxisFormat,
    yAxisFormat,
    xAxisFormatter,
    yAxisFormatter
  };
  const valueFormatter = useFormat(formatOptions);
  let {
    ChartContainer,
    ChartItem
  } = useMemo(() => {
    if (type === "area") {
      return {
        ChartContainer: AreaChart,
        ChartItem: Area
      };
    }
    if (type === "bar") {
      return {
        ChartContainer: BarChart,
        ChartItem: Bar
      };
    }
    if (type === "composed") {
      return {
        ChartContainer: ComposedChart,
        ChartItem: Line
      };
    }
    return {
      ChartContainer: LineChart,
      ChartItem: Line
    };
  }, [type]);
  const {
    lastChartData,
    margin,
    yTicks
  } = useMemo(() => {
    const _margin = {
      top: 0,
      left: -52,
      right: 0,
      bottom: 6
    };
    const timeFormatter = (v) => getFormatValue(v, isVertical ? yAxisFormat : xAxisFormat);
    const nameFormatter = (v) => {
      if (isVertical) {
        return yAxisFormatter(timeFormatter(v));
      }
      return xAxisFormatter(timeFormatter(v));
    };
    const allValues = [];
    const allNames = [];
    const arrDataKyesMap = dataKeysToRender.reduce((dataKeyMap, current) => {
      if (!current.hide) {
        dataKeyMap[current.dataKey] = true;
      }
      return dataKeyMap;
    }, {});
    const _lastChartData = chartData.map((d) => {
      const formatName = nameFormatter(d.name);
      const lastD = {
        ...d
      };
      if (isVertical) {
        allNames.push(formatName);
      } else {
        for (const key in d) {
          if (arrDataKyesMap[key]) {
            allValues.push(Number(d[key]));
            if (d[key] !== null) {
              lastD[key] = Number(d[key]);
            }
          }
        }
      }
      return {
        ...lastD,
        name: formatName
      };
    });
    let yTicks2;
    if (isVertical) {
      const maxLengthName = allNames.reduce((_maxLengthName, currentName) => {
        if (getStringLength(String(currentName)) > getStringLength(String(_maxLengthName))) {
          return currentName;
        }
        return _maxLengthName;
      }, "");
      const maxYAislLabelWidth = getStringDOMWidth(maxLengthName);
      _margin.left = _margin.left + maxYAislLabelWidth;
    } else {
      if (stackOffset === "expand") {
        _margin.left = _margin.left + getStringDOMWidth("100%");
      } else {
        const maxValue = Math.max.apply(null, allValues);
        const minValue = (() => {
          const value = Math.min.apply(null, allValues);
          if (value > 0) {
            return 0;
          }
          return value;
        })();
        const tickValues = getNiceTickValues([minValue, maxValue], 5);
        const measuringValue = tickValues.reduce((acc, cur) => {
          const formatCur = String(valueFormatter(cur));
          if (formatCur.length > acc.length) {
            return formatCur;
          }
          return acc;
        }, "");
        if (minValue === 1 && maxValue === 1) {
          yTicks2 = [0, 1, 2, 3, 4];
        }
        const formatValue = String(valueFormatter(measuringValue));
        const maxXAislLabelWidth = getStringDOMWidth(formatValue);
        _margin.left = _margin.left + maxXAislLabelWidth;
      }
    }
    return {
      yTicks: yTicks2,
      lastChartData: _lastChartData,
      margin: _margin
    };
  }, [chartData, layout, stackOffset, dataKeysToRender]);
  const {
    xAxisProps,
    yAxisProps,
    tooltipProps
  } = useMemo(() => {
    let _xAxisProps = {};
    let _yAxisProps = {};
    let _tooltipProps = {};
    if (layout === "vertical") {
      _yAxisProps = {
        dataKey: "name",
        type: "category",
        padding: {
          top: 16,
          bottom: 16
        }
      };
      _xAxisProps = {
        type: "number",
        tickFormatter: valueFormatter,
        padding: {
          left: 16,
          right: 16
        }
      };
      const isPercent = xAxisFormat.includes("percent") && stackOffset === "expand";
      _tooltipProps = {
        formatter: isPercent ? null : valueFormatter,
        isPercent
      };
    } else {
      _xAxisProps = {
        dataKey: "name",
        padding: {
          left: 16,
          right: 16
        }
      };
      _yAxisProps = {
        tickFormatter: valueFormatter,
        padding: {
          top: 16,
          bottom: 16
        },
        ticks: yTicks
      };
      const isPercent = yAxisFormat.includes("percent") && stackOffset === "expand";
      _tooltipProps = {
        formatter: isPercent ? null : valueFormatter,
        isPercent
      };
    }
    return {
      xAxisProps: _xAxisProps,
      yAxisProps: _yAxisProps,
      tooltipProps: _tooltipProps
    };
  }, [layout, xAxisFormat, yAxisFormat]);
  const legendPayload = useMemo(() => dataKeys.map((dataKeyObj) => ({
    value: dataKeyObj.name || dataKeyObj.dataKey,
    type: "line",
    ...dataKeyObj
  })), [dataKeys]);
  const renderedItemLength = dataKeysToRender.reduce((acc, cur) => {
    let count = acc;
    if (!cur.hide) {
      count += 1;
    }
    return count;
  }, 0);
  const onLegendClick = (o) => {
    const {
      dataKey
    } = o;
    const _dataKeys = dataKeysToRender.map((dataKeyObj) => {
      const newDataKeyObj = {
        ...dataKeyObj
      };
      if (dataKeyObj.dataKey === dataKey) {
        if (renderedItemLength !== 1) {
          newDataKeyObj.hide = !newDataKeyObj.hide;
        } else {
          newDataKeyObj.hide = false;
        }
      }
      return newDataKeyObj;
    });
    setDataKeysToRender(_dataKeys);
  };
  const chartContent = /* @__PURE__ */ jsxs(ChartContainer, {
    width: width || 500,
    height: height || 300,
    data: lastChartData,
    layout,
    margin,
    stackOffset,
    ...restProps,
    className: classnames(styles.container, restProps.className),
    children: [/* @__PURE__ */ jsx(CartesianGrid, {
      strokeDasharray: "3 3"
    }), renderedItemLength > 0 && /* @__PURE__ */ jsx(XAxis, {
      ...xAxisProps
    }), renderedItemLength > 0 && /* @__PURE__ */ jsx(YAxis, {
      ...yAxisProps
    }), /* @__PURE__ */ jsx(Tooltip, {
      content: /* @__PURE__ */ jsx(RechartsTooltip, {
        isPercent: tooltipProps.isPercent
      }),
      ...tooltipProps,
      formatter: tooltipProps.formatter
    }), brush && /* @__PURE__ */ jsx(Brush, {}), dataKeys.length > 1 && /* @__PURE__ */ jsx(Legend, {
      iconType: "line",
      content: /* @__PURE__ */ jsx(CustomizedLegend, {
        customPayload: legendPayload,
        onClick: onLegendClick
      }),
      wrapperStyle: brush ? {
        bottom: -2
      } : {
        bottom: 0
      }
    }), dataKeysToRender.map((d, index) => {
      const {
        dataKey,
        chartType,
        stroke = colors[index],
        fill = colors[index],
        hide,
        ...restOptions
      } = d;
      if (hide) {
        return false;
      }
      if (type === "composed") {
        if (chartType === "line") {
          ChartItem = Line;
        } else if (chartType === "area") {
          ChartItem = Area;
        } else if (chartType === "bar") {
          ChartItem = Bar;
        }
      }
      const LastChartItem = ChartItem;
      return /* @__PURE__ */ jsx(LastChartItem, {
        type: "monotone",
        dataKey,
        stroke,
        fill,
        stackId: stackOffset === "expand" ? "1" : void 0,
        animationDuration: 500,
        ...restOptions
      }, dataKey);
    })]
  });
  if (useResponsiveContainer) {
    return /* @__PURE__ */ jsx("div", {
      style: {
        height
      },
      children: /* @__PURE__ */ jsx(ResponsiveContainer, {
        width: "100%",
        height,
        children: chartContent
      })
    });
  }
  return /* @__PURE__ */ jsx(Fragment, {
    children: chartContent
  });
}
VarietyChart.displayName = "VarietyChart";
VarietyChart.defaultProps = {
  layout: "horizontal",
  useResponsiveContainer: true,
  height: 300,
  brush: false
};
export {
  colors,
  VarietyChart as default
};
